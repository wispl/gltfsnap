#pragma once

#include <fastgltf/types.hpp>
#include <glad/gl.h>

#include <vector>

// Textures, this is simply just a GLuint, but is here as a NewType.
struct Texture {
	GLuint id;
};

struct Material {
	fastgltf::math::fvec4 base_color;
	float metallic;
	float roughness;
};

// Texture and position coordinates, we interleave vertice data.
struct Vertex {
	fastgltf::math::fvec3 pos;
	fastgltf::math::fvec2 uv;
};

// A OpenGL struct which species a draw command for MultiDrawElements.
struct DrawCommand {
	std::uint32_t count;		// how many indices
	std::uint32_t instance_count;	// how many instances to draw
	std::uint32_t first_index;	// offset to the first indice
	std::int32_t base_vertex;	// offset to the first vertex
	std::uint32_t base_instance;	// offset for when drawing multiple instances
};


// A primitive is some surface assigned to a material. A draw command specifies
// how to draw this surface and a material id, generated by us, species what
// material to use.
struct Primitive {
	DrawCommand draw_command;
	std::size_t material_id;
	GLint albedo_texture;

	// TODO: see if these are neccessary, it might be possible to always
	// assume drawing triangles and an uint32_t as the index type
	// GLenum primitive_type;
	// GLenum index_type;
};

// A Mesh is constructed from a series of primitives. Vertices and indices are
// stored per mesh and draw commands are used to index it.
struct Mesh {
	GLuint vertex_buffer, index_buffer;
	std::vector<Primitive> primitives;
};

// Contains all information needed to render a GLTF. Meshes depend on materials
// which depend on textures.
struct LoadedGLTF {
	std::vector<Texture> textures;
	std::vector<Material> materials;
	std::vector<Mesh> meshes;
	// TODO: see if we have to handle nodes
	// std::vector<Node> nodes;
};

LoadedGLTF load_gltf(std::filesystem::path path);
